@page "/dashboard"
@using Diplom.Shared
@inherits LayoutComponentBase
@inject ThemeStateService themeStateService;
@inject ColorService ColorService;

<div class="grid-container">
    <div class="griditem top-left">
        <p>Reststrom</p>
        <p>im Speicher</p>
        <p class="values">@reststromPercentage %</p>
    </div>
    <div class="griditem top-right">
        <p>Hashrate</p>
        <p>der Miner</p>
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="error-message">
                @errorMessage
            </div>
        }else
        {
            <EditableFieldComponent Value="@hashrateValue" ValueChanged="UpdateHashrateValue" />
        }
    </div>
    <div class="griditem bottom-group">
        <div class="upper">
            <p>Aktueller Niederschlag</p>
            <p class="values" style="margin-top: -10px">@niederschlagPercentage %</p>
        </div>
        <div class="lower">
            <DayWeatherComponent></DayWeatherComponent>
        </div>
    </div>
</div>



@{
    bool useDarkTheme = themeStateService.UseDarkTheme;
    string themeBackgroundColor = useDarkTheme ? "#141218" : "#dbd4c6";
    string themeCardColor = useDarkTheme ? "#2B2930" : "#F3EEEA";
    string themeTextColor = useDarkTheme ? "#FFFFF0" : "#776B5D";
}


<style>

    body{
        overflow: hidden;
        color: @themeTextColor !important;
        background-color: @themeBackgroundColor !important;
    }

    .grid-container {
        margin-top: -100px;
        margin-right: 100px;
        margin-left: 100px;
        display: grid;
        grid-template-columns: 1fr 1fr; /* Two columns with equal width */
        grid-template-rows: 1fr 1fr; /* Two rows with equal height */
        gap: 150px;
    }

    .top-left {
        height: 400px;
        padding: 10px;
        position: relative;
    }

    .top-right {
        height: 400px;
        padding: 10px;
    }

    .bottom-group {
        grid-column: span 2;
        padding: 10px;
        height: 300px;
    }

    .griditem {
        background-color: @themeCardColor;
        border-radius: 25px;
        position: relative;
        align-items: center;
        justify-content: center;
    @{
        if (useDarkTheme == true)
        {
            <text>border: solid 2px #EADDFF</text>
        }
        else
        {
            <text>-webkit-box-shadow: 0px 3px 5px 0px rgba(0,0,0,0.5);
                box-shadow: 0px 3px 5px 0px rgba(0,0,0,0.5);
            </text>
        }
    }
    }

    .editable {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    p {
        text-align: center;
        font-size: 300%;
        font-family: 'Inter', sans-serif;
    }

    .values {
        margin-top: 50px;
        font-weight: bold;
        color: @textcolor;
    }

    .bottom-group {
        /* Two rows with equal height */
        grid-template-rows: 1fr 1fr;
    }

    .upper {
        height: 50%;
    }

    .lower {
        height: 50%;
        width: 100%;
    }
</style>


@code {
    private static readonly HttpClient client = new HttpClient();

    private float reststromPercentage = 0;
    private int hashrateValue = 0;
    private int niederschlagPercentage = 42;
    private string textcolor = "";

    private string errorMessage = "";

    protected override async Task OnInitializedAsync()
    {
        textcolor = await ColorService.getColorAsync();
        ColorService.ColorChanged += UpdateColor;
        GetHashrate();
        GetStrom();

        await base.OnInitializedAsync();

        // Introduce a delay of 1 second (1000 milliseconds)
        await Task.Delay(150);

        // Trigger re-render
        StateHasChanged();
    }

    private async void GetStrom()
    {
        var responseString = await client.GetStringAsync("https://localhost:7000/api/Pvanlage/GetPv");
        dynamic jsonResponse = JsonConvert.DeserializeObject(responseString);

        // Extract rate from the response
        reststromPercentage = jsonResponse[0]?.rate;
        Console.WriteLine(reststromPercentage);
        StateHasChanged();
    }

    private async void GetHashrate()
    {
        try
        {
            // Check if there is a DB entry
            var responseString = await client.GetStringAsync("https://localhost:7294/api/User/GetSettings");
            List<Usersettings> usersettings = JsonConvert.DeserializeObject<List<Usersettings>>(responseString);

            var settingsstring = await client.GetStringAsync("https://localhost:7294/api/Miner/GetMiner");
            List<Miner> minersfromdb = JsonConvert.DeserializeObject<List<Miner>>(settingsstring);
            // Calculate hashrate if there are entries
            float sum = 0;
            foreach (Miner m in minersfromdb)
            {
                sum += m.Hashrate;
            }
            float calculatedHashrate = sum / minersfromdb.Count;

            // Update hashrateValue
            this.hashrateValue = (int)Math.Ceiling(calculatedHashrate);
            StateHasChanged();
        }
        catch (HttpRequestException ex)
        {
            // Handle the exception by displaying an error message
            errorMessage = $"Error loading miner data: {ex.Message}";
        }
    }

    private void UpdateColor(string color)
    {
        textcolor = color;
        StateHasChanged(); // Notify Blazor to re-render the component
    }

    public void Dispose()
    {
        ColorService.ColorChanged -= UpdateColor;
    }


    private async void UpdateHashrateValue(int newValue)
    {
        try
        {
            var response = await client.PutAsync("https://localhost:7294/api/Miner/UpdateAllHashrates", new StringContent(newValue.ToString(), Encoding.UTF8, "application/json"));
            hashrateValue = newValue;
        }
        catch (HttpRequestException ex)
        {
            // Handle the exception by displaying an error message
            errorMessage = $"Error updating hashrate: {ex.Message}";
        }

        // Introduce a delay of 1 second (1000 milliseconds)
        await Task.Delay(100);

        // Trigger re-render
        StateHasChanged();
    }
}